%Este es el código para solucionar de manera exacta un modelo de
%optimización multiobjetivo (como aproximación se trabajan las dos
%funciones de manera independiente), el cual hace parte del proyecto de
%investigación titulado: Modelo de optimización multiobjetivo para la
% programación de la producción agrícola a pequeña escala en Santander,
% Colombia, desarrollado por Leonardo Talero, bajo la dirección de Henry
% Lamos & Edwin Garavito.

% El Script se divide en 3 partes que se describen a continuación:

% 1)______________________________________________________________________
% Se ingresan los parámetros del modelo, los cuales dependen de
% instancias generadas, por tanto, existirán múltiples archivos .mat, los
% cuales tienen almacenadas las inctancias y serán cargadas al principio
% del documento. Además, en esta sección se construyen los vectores que se
% utilizarán para generar las restricciones. (vectores b)
% 2)______________________________________________________________________
% Se construyen las matrices de restricción, el problema ha sido abordado
% como un modelo de optimización entera mixta, en esta sección se construye
% también el vector solución.
% 3)______________________________________________________________________
% Se evalúa el modelo, mediante la aplicación de una función ya existente
% en MATLAB, se generan las salidas del modelo.

%Limpieza de variables
clearvars
clc
%Contador del tiempo de cómputo
tic
% ========================================================================
%=============================SECCIÓN # 1=================================
% ========================================================================

%Cargar parámetros de los productos: Duración promedio de maduración,
%periodos cuando se puede recoger el producto, etc. Todos los productos
%están organizados alfabéticamente en orden descendentes (filas) con el fin
%de evitar recurrir a parámetros como el nombre o un identificador.

% load('productos_parametros.mat')
% Conjunto_s: Vector con los instantes donde puede sembrarse cada producto.
% q:          Familia botánica a la que pertenece cada producto.
% Ni:         Número de periodos que se demora el producto k en "Madurar".
% Pkt:        Precio de venta del producto K en el instante t
% Rkl:        Rendimiento en Kg/m2 de cada producto (col) por lote (fil)
% Al:         Área en metros de cada lote
% Gv          Grupo de productos sustitutos para satisfacer una demanda

%====Variables para la instancia de prueba

% productos = datasample(1:21,3,'Replace',false);%Selecciono al azar 3 productos
% lotes=datasample(1:length(Rkl(:,1)),2,'Replace',false);%Selecciono al azar 2 lotes
% q=q(productos);
% Conjunto_s=Conjunto_s(productos,:);
% Ni=Ni(productos);
% Pkt=Pkt(productos,:);
% Rkl=Rkl(lotes,productos);
% Al=Al(lotes');
load('instancia_prueba.mat')
B=100000;
%Cantidad de periodos
T=96;
% Cantidad de productos
K=length(Ni);
% Cantidad de lotes
L=length(Al);
% Estimar la matriz de Covarianza de los precios;
Covkkp=cov((Pkt)');
% Se crea el conjunto de instantes de recogida.
Conjunto_r=Conjunto_s*0;
Restriccion_re=zeros(1,T*K*L);
% Se calcula el conjunto de recogida para cada producto:

% Bucle que recorre cada producto
for k=1:K
    % Ubicar los posibles periodos de siembra, posterior a ello, calcular
    % el periodo de madurez Ni, de tal manera que re=s+Ni para cada
    % producto. Como el conjunto de siembra y pro tanto el de recogida
    % tiene dimensiones k*T, estas deben ser transformadas a un vector, con
    % el fin de utilizarlas como restricciones.
    Conjunto_r(k,find(Conjunto_s(k,:)==1)+Ni(k))=1;
    % El conjunto de recogida es almacenado para un único lote y debe ser
    % completado en un bucle de lotes (para evitar la creación de bucles
    % extras)
    Restriccion_re(((T*(k-1))+1:(T*(k-1))+T))=Conjunto_r(k,1:T);
end
% Se acota el conjunto de recogida para futuros cálculos
Conjunto_r=Conjunto_r(:,1:T);
% Se crea el conjunto para determinar el área máxima de siembra para cada
% periodo, este conjunto funciona como restricción.
Restriccion_Al=zeros(1,T*K*L);
for l=1:L
    % Se almacena el valor del área Al(l) para cada conjunto de tamaño k*T
    Restriccion_Al(((T*K)*(l-1)+1:(T*K*l)))=Al(l);
    % Se aprovecha el bucle de lotes para completar el vector de recogidas
    Restriccion_re(((T*K)*(l-1)+1:(T*K*l)))=Restriccion_re(1:(T*K));
end
%

% ========================================================================
%=============================SECCIÓN # 2=================================
% ========================================================================

% ========================================================================
% Familia de restricciones #1: No negatividad
% ========================================================================
% Como son restricciones de no negatividad y se trabaja con la función
% intlinprog, la no negatividad se modelo mediante el vector LB (Lower
% Bound, Límite Inferior).
% ========================================================================

% ========================================================================
% Familia de restricciones #2: Periodos de recogida
% ========================================================================

% Se genera una matriz identidad en las variables Y (dicotómica de recogida
% del producto):
A1=eye(T*K*L,T*K*L*4);

% El vector b1 es la transpuesta del vector Restriccion_re
b1=Restriccion_re';
% ========================================================================

% La matriz relaciona las variables de decisión Y (dicotómica) con Z
% (contínua) a partir de la premultiplicación por un número muy grande, por
% tanto, la matriz de restricciones se compone de dos diagonales y un
% espacio vacío:
A2=cat(2,eye(T*K*L,T*K*L)*(-B),zeros(T*K*L,T*K*L),eye(T*K*L,T*K*L),zeros(T*K*L,T*K*L));

% El vector b2 es igual a un vector 0
b2=b1*0;
% ========================================================================


% ========================================================================
% Familia de restricciones #3: Área destinada a siembra
% ========================================================================

% La matriz indica el área máxima destinada a cda cultivo (variable Z), por
% tanto, se modela como una diagonal igualada a la restricción:
A3=cat(2,zeros(T*K*L,T*K*L),zeros(T*K*L,T*K*L),eye(T*K*L,T*K*L),zeros(T*K*L,T*K*L));

% El vector b3 es la transpuesta del vector Restriccion_Al
b3=Restriccion_Al';
% ========================================================================

% ========================================================================
% Familia de restricciones #4: Satisfacción de la demanda
% ========================================================================
% Para el caso particular, se considera que existen productos sustitutos y,
% por tanto, estos pueden satisacer una misma demanda. Para agrupar los
% productos se cuenta con el parámetro Gv, el cual indica a cuál familia de
% productos sustitutos pertenecen los productos k, como es posible que no
% existan todos las familias a la vez (dependiendo de la instancia), es
% necesario determinar cuáles familias existen y crear una familia de
% restricciones (matriz) por cada familia:

% Determinar la cantidad de familias
F_Gv = unique(Gv);
% Se actualiza la demanda para la cantidad de familias
Demanda_Gv=Demanda_Gv(F_Gv);

% Como la demanda cambia periodo a periodo, el tamaño de la matriz A4 es
% igual a la cantidad de familias a satisfacer en cada tiempo (en ls filas)
% (length(F_Gv)*T) por la cantidad de variables de decisión:

A4=zeros(length(F_Gv)*T,T*K*L*4);
% por su parte, el vectyor b4 tendrá la misma cantidad de filas y se
% subdividirá en tantas demandas como familias Gv existan:
b4=zeros(length(F_Gv)*T,1);
% Como se construye tantas submatrices como familias, se genera un bucle:
% Desde la primera familia hasta la última
for fgv=1:length(F_Gv)
    % Como se debe recorrer todos los productos para determinar si
    % pertenecen o no a la misma familia Gv, se genera un bucle y se asigna
    % una submatriz identidad a aquellos productos que se van a relacionar
    % y una submatriz de ceros a aquellos que no pertenecen, se definen a
    % continuación:
    
    M_identidad=eye(T,T);
    M_ceros=zeros(T,T);
    
    % Además, se asignan los valores de demanda para el vector b4:
    b4(((fgv-1)*T+1:(fgv-1)*T+T))=Demanda_Gv(fgv);
    
    % Para cada uno de los lotes
    for l=1:L
        % Para cada uno de los productos
        for k=1:K
            if Gv(k)==F_Gv(fgv)
                A4(((fgv-1)*T+1:(fgv-1)*T+T),((T*K*L*2)+(T*K)*(l-1)+T*(k-1)+1:(T*K*L*2)+(T*K)*(l-1)+T*(k-1)+T))=M_identidad;
            else
                A4(((fgv-1)*T+1:(fgv-1)*T+T),((T*K*L*2)+(T*K)*(l-1)+T*(k-1)+1:(T*K*L*2)+(T*K)*(l-1)+T*(k-1)+T))=M_ceros;
            end
        end
    end
end
% ========================================================================

% ========================================================================
% Familia de restricciones #5: Evitar solapamiento
% ========================================================================
% Para evitar el solapamiento de los productos, se tiene en cuenta un
% producto k, el cual puede ser recogido en un instante de tiempo t, todos
% los productos (incluyendo al producto k) no pueden ser recogidos mientras
% dure el periodo de madurez del producto k, por tanto, se debe generar una
% submatriz de cargas que tenga como límite superior el instante de
% recogida -1 (t-1), y abarque el periodo de madurez del producto K. Por
% comodidad, se genera una matriz general (aún cuando el producto k no
% pueda ser recogido en el instante t=1). La cantidad de restricciones en
% este caso es igual al número de variables de decisión, por tanto, la
% matriz A5 inicial es igual a:

A5=zeros(K*T*L,K*T*L*4);
% Se hace un recorrido para cada lote
for l=1:L
    %     Para evitar excesos de bucles se calcula todo en el primer lote y se
    %     reproduce para los lotes posteriores
    if l==1
        %     Se realiza un recorrido para cada producto
        for k=1:K
            %         Se ubican las filas correspondientes al intervalo de
            %         madurez del producto:
            [row col] = (find(eye(T,T).*Conjunto_r(k,:)==1));
            %         Se define el intervalo de madurez previo a la
            %         recogida de cada producto
            intervalo_madurez=[find(Conjunto_r(k,1:T)==1)-Ni(k);find(Conjunto_r(k,1:T)==1)-1];
            %         Se contruye una matriz para registar los periodos de
            %         madurez
            M_madurez=zeros(T,T);
            %             Se realiza un bucle para cada uno de los posibles
            %             periodos de madurez
            for i=1:length(intervalo_madurez)
                M_madurez(row(i),intervalo_madurez(1,i):intervalo_madurez(2,i))=1;
            end
            
            %            fila1= (T)*(k-1)+(T*K)*(l-1)+1
            %             fila2=(T)*(k-1)+(T*K)*(l-1)+T
            %             col1=1
            %             col2=(T*K)
            %         Se repite el patrón para todos los productos
            A5((T)*(k-1)+(T*K)*(l-1)+1:(T)*(k-1)+(T*K)*(l-1)+T,1:(T*K))=repmat(M_madurez,1,K);
            %         Se Agrega la diagonal en el producto correspondiente:
            A5((T)*(k-1)+1:(T)*(k-1)+T,(T)*(k-1)+1:(T)*(k-1)+T)=A5((T)*(k-1)+1:(T)*(k-1)+T,(T)*(k-1)+1:(T)*(k-1)+T)+eye(T,T).*Conjunto_r(k,:);
        end
    else
        A5(K)=A(1:K*T,1:K*T)
    end
end

% ========================================================================
% Familia de restricciones #6
% ========================================================================

% ========================================================================
%=============================SECCIÓN # 3=================================
% ========================================================================



[row col] = (find(eye(T,T).*Conjunto_r(1,:)==1));

size(Conjunto_r)
intervalo_madurez=[find(Conjunto_r(1,1:96)==1)-Ni(1);find(Conjunto_r(1,1:96)==1)-1];

M_madurez=zeros(T,T);
for i=1:12
    M_madurez(row(i),intervalo_madurez(1,i):intervalo_madurez(2,i))=1;%madurez -1 para el producto 1
end
M_identidad.*Conjunto_r(1,:);%restricción diagonal para el producto1
toc